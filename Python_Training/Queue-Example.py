#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# https://docs-python.ru/standart-library/modul-queue-python/ochered-fifo/

# Класс Queue() модуля queue представляет собой конструктор для многопоточной очереди FIFO (первым пришел - первым вышел).

# Аргумент maxsize - это целое число, которое устанавливает верхний предел для количества элементов, которые могут быть помещены в очередь. Вставка будет блокироваться после достижения этого размера, пока элементы очереди не будут использованы.

# Если maxsize меньше или равен нулю, размер очереди бесконечен.

# Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:

# В очереди FIFO первые добавленные задачи являются первыми извлеченными.
# В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек).
# В очереди с приоритетами записи сохраняются отсортированными с использованием модуля heapq и сначала извлекается запись с наименьшим значением.

# Очередь FIFO:
# Класс queue.Queue() реализует базовый контейнер типа FIFO - "первым пришел - первым вышел". Элементы добавляются к одному концу очереди с помощью метода put(), а удаляются с другого конца с помощью метода get().


import queue

q = queue.Queue()

for i in range(5):
	q.put(i)

while not q.empty():
	print(q.get(), end=' ')


# 0 1 2 3 4

# Очередь LIFO:
# В отличие от стандартной реализации очереди FIFO, в queue.LifoQueue() используется порядок "последним пришел - первым вышел", который обычно связан со структурой данных стека.

import queue

q = queue.LifoQueue()

for i in range(5):
    q.put(i)

while not q.empty():
    print(q.get(), end=' ')

# 4 3 2 1 0

# Очередь с приоритетом:
# Иногда порядок обработки элементов в очереди должен основываться на характеристиках этих элементов, а не только на порядке их создания или добавления в очередь. Например, задания на печать из финансового отдела могут иметь приоритет над списком заданий из отдела технической поддержки. Класс модуля queue.PriorityQueue() использует порядок сортировки содержимого очереди, чтобы решить, какой элемент получить.

import functools
import queue
import threading


@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented

def process_job(q):
    while True:
        next_job = q.get()
        print('Processing job:', next_job.description)
        q.task_done()

q = queue.PriorityQueue()
q.put(Job(3, 'Mid-level'))
q.put(Job(10, 'Low-level'))
q.put(Job(1, 'Important'))

workers = [
    threading.Thread(target=process_job, args=(q,)),
    threading.Thread(target=process_job, args=(q,)),
]
for w in workers:
    w.setDaemon(True)
    w.start()

q.join()

# Этот пример имеет несколько потоков, потребляющих задания, которые обрабатываются на основе приоритета элементов в очереди на момент вызова get(). Порядок обработки элементов, добавляемых в очередь во время работы потоков-потребителей, зависит от переключения контекста потока.

Processing job: Important job
Processing job: Mid-level job
Processing job: Low-level job



# https://docs-python.ru/standart-library/modul-queue-python/obekty-ocheredi-modulja-queue/

Объект многопоточной очереди модуля queue.

Объекты очереди создаются в момент инициализации классов queue.Queue(), queue.LifoQueue() или queue.PriorityQueue() и имеют открытые методы, описанные ниже.

Содержание:
Размер очереди Queue.qsize(),
True, если очередь пуста Queue.empty(),
True, если очередь заполнена Queue.full(),
Положить элемент в очередь Queue.put(),
Разместить элемент в очереди без ожидания Queue.put_nowait(),
Получить элемент из очереди Queue.get(),
Эквивалентен вызову Queue.get(False) Queue.get_nowait(),
Сообщить очереди, что задача завершена Queue.task_done(),
Заблокировать очередь Queue.join(),
Пример работы с очередью (ожидания выполнения задач очереди).



Queue.qsize():
Метод Queue.qsize() возвращает примерный размер очереди.

Обратите внимание, что SimpleQueue.qsize() > 0 не гарантирует, что последующий метод Queue.get() не будет блокироваться.


Queue.empty():
Метод Queue.empty() возвращает True, если очередь пуста, иначе False.

Если SimpleQueue.empty() возвращает False, это не гарантирует, что последующий вызов метода Queue.get() не будет блокирован.


Queue.full():
Метод Queue.full() возвращает True, если очередь заполнена и False в противном случае.

Если Queue.full() возвращает True, это не гарантирует, что последующий вызов Queue.get() не будет блокирован.
Аналогично, если Queue.full() возвращает False, это не гарантирует, что последующий вызов Queue.put() не будет блокирован.

Queue.put(item, block=True, timeout=None):
Метод Queue.put() размещает элемент item в очереди.

Если необязательный аргумент block имеет значение True, а время ожидания равно None (по умолчанию), то при необходимости добавление элемента в очереди блокируется, пока не освободится свободный слот.

Если тайм-аут timeout является положительным числом, то добавление элемента в очередь блокируется на максимальное время ожидания timeout и если в течение этого времени не было свободного места, то выдается исключение queue.Full. В противном случае, когда block=False и если свободный слот сразу же доступен, то элемент item добавляется в очередь, иначе вызывается исключение queue.Full. В этом случае аргумент тайм-аут timeout игнорируется.


Queue.put_nowait(item):
Метод Queue.put_nowait() эквивалентен вызову метода Queue.put(item, False) с указанными параметрами.


Queue.get(block=True, timeout=None):
Метод Queue.get() возвращает, а затем удаляет элемент из очереди.

Если необязательный аргумент block имеет значение True, а время ожидания timeout=None (по умолчанию), то при необходимости происходит блокировка, на время пока элемент не станет доступен.

Если тайм-аут timeout является положительным числом, то извлечение элемента из очереди блокируется на максимальное время ожидания timeout и если в течение этого времени ни один элемент не был доступен, то вызывается исключение queue.Empty. В противном случае, когда block=False и если элемент сразу доступен, то элемент возвращается, иначе вызывается исключение queue.Empty,в этом случае timeout игнорируется.

Для всех версий в Windows, если block=True и время ожидания timeout=None, то эта операция переходит в непрерывное ожидание базовой блокировки. Это означает, что исключений может не быть, и в частности, SIGINT не будет вызывать KeyboardInterrupt.


Queue.get_nowait():
Метод Queue.get_nowait() эквивалентен вызову метода Queue.get(False).

Для поддержки отслеживания того, были ли поставленные в очередь задачи полностью обработаны потоками-потребителями демонов, объекты очереди предлагают два метода.


Queue.task_done():
Метод Queue.task_done() указывает, что ранее поставленная в очередь задача выполнена. Используется потоками очереди.

Для каждого вызова Queue.get(), используемого для извлечения задачи, последующий вызов метода Queue.task_done() сообщает очереди, что обработка задачи завершена.

Если соединение в данный момент блокируется вызовом метода Queue.join(), то оно возобновится, когда все элементы будут обработаны. Это означает, что вызов Queue.task_done() был получен для каждого элемента, который был помещен в очередь.

Метод Queue.task_done() вызывает исключение ValueError, если вызывается больше раз, чем было размещено элементов в очереди.


Queue.join():
Метод Queue.join() блокирует соединение, пока все элементы в очереди не будут получены и обработаны.

Количество незавершенных задач увеличивается при каждом добавлении элемента в очередь. Счетчик уменьшается, когда потребительский поток вызывает метод Queue.task_done(), тем самым указывая, что элемент был получен и вся работа над ним завершена. Когда количество незавершенных задач падает до нуля, то Queue.join() разблокируется.


Пример работы с очередью (ожидание выполнения задач).
import threading, queue

q = queue.Queue()

def worker():
    while True:
        item = q.get()
        print(f'Working on {item}')
        print(f'Finished {item}')
        q.task_done()

# Включить рабочий поток
threading.Thread(target=worker, daemon=True).start()

# Отправить тридцать запросов на выполнение worker()
for item in range(30):
    q.put(item)
print('Все задачи отправлены\n', end='')

# Блокировать, пока все задачи не будут выполнены
q.join()
print('Все задачи завершены')


# https://docs-python.ru/standart-library/modul-queue-python/iskljuchenija-modulja-queue/
Исключения модуля queue в Python.

Модуль синхронизированной очереди queue определяет два исключения:

queue.Empty:
Исключение queue.Empty возникает, когда неблокирующая функция get() или get_nowait() вызывается для объекта очереди Queue, который пуст.

queue.Full:
Атрибут queue.Full возникает, когда неблокирующая функция put() или put_nowait() вызывается для объекта очереди Queue, который заполнен.












